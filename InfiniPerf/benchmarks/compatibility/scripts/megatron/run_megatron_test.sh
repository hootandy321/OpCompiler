#!/bin/bash

# ==============================================================================
# 脚本配置与错误处理
# ==============================================================================
set -e
set -o pipefail

# ==============================================================================
# 定义辅助函数
#
# 将重复的逻辑封装成函数，可以让主流程更清晰。
# ==============================================================================

# 定义一个函数，用于打印带有时间戳和高亮标题的日志
log() {
    # 打印黄色的标题和当前时间
    echo -e "\n\e[33m[$(date +'%Y-%m-%d %H:%M:%S')] --- $1 ---\e[0m"
}

# 定义一个函数，用于执行子脚本
# 它会先检查脚本是否存在，然后再 source 它
run_script() {
    local script_path="$1" # 将传入的第一个参数作为脚本路径

    log "正在准备执行脚本: ${script_path}"

    # 检查脚本文件是否存在并且是可读的
    if [ ! -f "${script_path}" ]; then
        echo -e "\e[31m错误：找不到脚本文件: ${script_path}，程序终止。\e[0m"
        exit 1 # 找不到文件，直接以失败状态退出
    fi

    # 使用 'source' (或 '.') 来执行脚本。
    source "${script_path}"
    
    echo -e "\e[32m成功：脚本 ${script_path} 执行完毕。\e[0m"
}


# ==============================================================================
# 主执行流程
# ==============================================================================
main() {
    
    log "正在初始化环境 (env.sh)"
    # 切换目录，加载环境变量，然后切回原目录。
    cd ../../../../ && source env.sh && cd -
    echo -e "\e[32m成功：环境初始化完毕。\e[0m"

    # 依次执行后续的各个脚本
    run_script "./build.sh"
    run_script "./remove_cache_data.sh"
    run_script "./process_data.sh"

    LOG_FILE="pretrain_llama.log"
    > "${LOG_FILE}" # 清空上一次的日志内容
    run_script "./pretrain_llama.sh" 2>&1 | tee -a "${LOG_FILE}"

    exit_status=${PIPESTATUS[0]}
    if [ ${exit_status} -eq 0 ]; then
        echo -e "\e[32m成功：脚本 pretrain_llama.sh 执行完毕。\e[0m" | tee -a "${LOG_FILE}"
    else
        echo -e "\e[31m失败：脚本 pretrain_llama.sh 执行时发生错误。\e[0m" | tee -a "${LOG_FILE}"
    fi

    log "所有任务已成功完成！"
}

# ==============================================================================
# 调用 main 函数来启动整个脚本
# ==============================================================================
main

