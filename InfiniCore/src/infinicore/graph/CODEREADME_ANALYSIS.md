# Graph 计算图执行框架 - 架构分析

## 1. 子系统职责

`graph` 目录是 InfiniCore 的**计算图执行框架实现层**，负责提供计算图的构建、管理和执行能力。该子系统实现了声明式计算图 API，支持通过"录制模式"构建计算图，然后批量执行整个计算图，从而为编译时优化和硬件抽象提供基础。

作为叶子节点实现层，本目录包含两个核心源文件：
- **graph.cc**: 核心类的具体实现（GraphTensor、GraphOperator、Graph、GraphManager）
- **graph_manager.hpp**: GraphManager 类声明（计算图录制管理器）

本目录与头文件目录（`include/infinicore/graph/`）共同构成完整的计算图框架：头文件定义公共接口和宏系统，本目录提供具体实现代码。

## 2. 模块导航

由于本目录是**叶子节点**（不包含子目录），仅包含源代码实现文件：

* **graph.cc**
    * *功能*: 实现计算图框架的核心类方法，包括 GraphTensor 构造、GraphOperator 执行与清理、Graph 批量执行、GraphManager 录制控制
    * *职责*: 提供计算图执行框架的具体实现逻辑

* **graph_manager.hpp**
    * *功能*: 定义 GraphManager 类接口，管理计算图录制状态和当前计算图实例
    * *职责*: 提供计算图录制生命周期管理（开始、添加算子、停止）

**相关文档**：
- `include/infinicore/graph/CODEREADME.md`: 包含完整的计算图框架架构文档、API 说明和使用示例

## 3. 架构逻辑图解

### 3.1 核心类关系与协作流程

```
┌─────────────────────────────────────────────────────────────┐
│                     用户代码层 (User Code)                    │
│   INFINICORE_GRAPH_OP_RECORD_OR_RUN(MatMulOp, A, B, C)      │
└───────────────────────────┬─────────────────────────────────┘
                            │ 检测录制模式
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  GraphManager (录制管理器)                    │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ start_recording() → recording_ = true               │    │
│  │ add_operator(op) → graph_->add_operator(op)         │    │
│  │ stop_recording() → return graph_                    │    │
│  └─────────────────────────────────────────────────────┘    │
└───────────────────────────┬─────────────────────────────────┘
                            │ 管理当前计算图
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                       Graph (计算图)                          │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ op_list_: vector<shared_ptr<GraphOperator>>         │    │
│  │                                                      │    │
│  │ run() {                                              │    │
│  │   for (auto &op : op_list_) { op->run(); }          │    │
│  │ }                                                    │    │
│  └─────────────────────────────────────────────────────┘    │
└───────────────────────────┬─────────────────────────────────┘
                            │ 包含多个算子
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   GraphOperator (算子抽象)                     │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ planned_meta_: void*  (硬件特定的执行元数据)           │    │
│  │ runner_: run_schema  (执行函数指针)                   │    │
│  │ deleter_: cleanup_schema (清理函数指针)              │    │
│  │                                                      │    │
│  │ run() { runner_(planned_meta_); }                   │    │
│  └─────────────────────────────────────────────────────┘    │
└───────────────────────────┬─────────────────────────────────┘
                            │ 包装
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   GraphTensor (张量包装)                       │
│              继承自 Tensor，用于计算图中的张量                  │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 执行模式：录制模式 vs. 即时执行模式

计算图框架支持两种执行模式，通过 `GraphManager::recording_` 状态控制：

**模式 1：即时执行模式 (默认)**
```
用户调用算子
    ↓
检查 context::isGraphRecording() → false
    ↓
直接执行: op->run()
    ↓
硬件特定执行函数立即运行
```

**模式 2：录制模式**
```
用户调用 GraphManager::start_recording()
    ↓
recording_ = true, 创建新 Graph 实例
    ↓
用户调用算子
    ↓
检查 context::isGraphRecording() → true
    ↓
录制: context::addGraphOperator(op)
    ↓
GraphManager::add_operator(op)
    ↓
Graph::add_operator(op) → 添加到 op_list_
    ↓
用户调用 GraphManager::stop_recording()
    ↓
返回完整 Graph 对象
    ↓
graph->run() → 批量执行所有算子
```

### 3.3 硬件抽象与算子分发

```
┌─────────────────────────────────────────────────────────────┐
│           算子定义宏 (INFINICORE_GRAPH_OP_CLASS)              │
│            生成继承自 GraphOperator 的算子类                   │
└───────────────────────────┬─────────────────────────────────┘
                            │ 构造时调用
                            ▼
┌─────────────────────────────────────────────────────────────┐
│        算子分发宏 (INFINICORE_GRAPH_OP_DISPATCH)              │
│   planned_meta_ = plan_dispatcher().lookup(CUDA)(args)       │
│   runner_ = run_dispatcher().lookup(CUDA)                    │
│   deleter_ = cleanup_dispatcher().lookup(CUDA)               │
└───────────────────────────┬─────────────────────────────────┘
                            │ 函数指针查询
                            ▼
┌─────────────────────────────────────────────────────────────┐
│        OpDispatcher<plan_schema> (分发器)                     │
│     根据 DeviceType (CUDA/CPU/Kunlun/etc.) 解析              │
│     硬件特定的 plan/run/cleanup 函数                          │
└───────────────────────────┬─────────────────────────────────┘
                            │ 注册实现
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  注册宏 (INFINICORE_GRAPH_OP_REGISTER_ALLDEVICE)             │
│  在静态初始化时注册所有硬件后端的实现函数                       │
└─────────────────────────────────────────────────────────────┘
```

### 3.4 内存管理与资源清理

```
Graph (shared_ptr)
    │
    ├── op_list_: vector<shared_ptr<GraphOperator>>
    │       │
    │       └── GraphOperator 实例 (shared_ptr 管理)
    │               │
    │               ├── planned_meta_: void* (硬件特定元数据)
    │               │     │
    │               │     └── deleter_(planned_meta_) 在析构时清理
    │               │
    │               └── runner_: 函数指针 (无需清理)
    │
    └── 析构时自动清理所有 shared_ptr → 触发 GraphOperator 析构
            → 调用 deleter_ 释放硬件资源
```

### 3.5 关键设计模式

1. **Builder Pattern（建造者模式）**
   - `GraphManager` 作为建造者，逐步构建 `Graph` 对象
   - 录制期间增量添加算子，构建完成后返回完整的计算图

2. **Strategy Pattern（策略模式）**
   - `GraphOperator` 通过函数指针 (`runner_`, `deleter_`) 封装硬件特定的执行策略
   - 运行时根据 `DeviceType` 选择具体的硬件实现

3. **RAII（资源获取即初始化）**
   - `GraphOperator` 析构函数自动调用 `deleter_` 清理硬件资源
   - `Graph` 通过 `shared_ptr` 管理算子生命周期

4. **Static Registration（静态注册）**
   - 使用函数局部静态变量和 lambda 初始化器注册算子实现
   - 程序启动时自动注册所有硬件后端的分发函数

### 3.6 数据流：算子定义到执行的完整流程

```
┌─────────────────────────────────────────────────────────────┐
│  1. 算子开发者定义算子 (使用宏系统)                            │
│     INFINICORE_GRAPH_OP_CLASS(MatMulOp, ...)                │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 实现构造函数 (调用分发宏)                                  │
│     MatMulOp::MatMulOp(...) {                               │
│       INFINICORE_GRAPH_OP_DISPATCH(DeviceType::CUDA, ...)  │
│     }                                                       │
└───────────────────────────┬─────────────────────────────────┘
                            │ 查询硬件特定函数
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 分发器解析函数指针                                        │
│     planned_meta_ = plan_dispatcher().lookup(CUDA)(args)    │
│     runner_ = run_dispatcher().lookup(CUDA)                │
└───────────────────────────┬─────────────────────────────────┘
                            │ 存储函数指针
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 用户代码使用算子 (录制或执行宏)                            │
│     INFINICORE_GRAPH_OP_RECORD_OR_RUN(MatMulOp, A, B, C)   │
└───────────────────────────┬─────────────────────────────────┘
                            │ 检测录制模式
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  5a. 即时执行模式: op->run() → runner_(planned_meta_)        │
│  5b. 录制模式: add_operator(op) → 添加到 graph->op_list_     │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  6. 计算图批量执行 (如果是录制模式)                             │
│     graph->run() → for op in op_list_: op->run()            │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  7. 硬件特定执行函数运行 (例如 CUDA Kernel)                    │
│     runner_(planned_meta_)                                   │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  8. 资源清理 (RAII)                                          │
│     Graph 析构 → shared_ptr 清理 → GraphOperator::~GraphOperator() → deleter_(&planned_meta_)
└─────────────────────────────────────────────────────────────┘
```

## 4. 与其他子系统的关系

```
graph (计算图框架)
    │ 依赖
    ├── tensor: Tensor 基类，GraphTensor 继承自 Tensor
    ├── context: 提供录制状态检测 (context::isGraphRecording())
    ├── common: OpDispatcher 模板，提供硬件特定分发机制
    └── utils: INFINICORE_ASSERT 宏用于断言检查
```

**向上提供接口**：
- 为 Python 绑定层（`infinicore/pybind11/graph.hpp`）提供 C++ API
- 为上层算子库（MatMul、Conv2D 等）提供计算图录制能力

**向下依赖基础组件**：
- 依赖 Tensor 提供数据抽象
- 依赖 Context 提供执行模式上下文
- 依赖 OpDispatcher 提供硬件分发机制

## 5. 文档完整性说明

本目录作为叶子节点，已完成代码实现分析。完整的架构文档位于：
- `/home/qy/src/Infini/InfiniCore/include/infinicore/graph/CODEREADME.md`

该文档包含：
- 详细的类职责和方法说明
- 完整的宏系统 API 文档
- 使用示例（MatMul 算子定义与使用）
- 实现细节（内存管理、硬件抽象、性能优化）
- 设计模式分析（策略模式、建造者模式、RAII、静态注册）
